#include <bits/stdc++.h>

/* В большой IT-фирме есть только одна переговорная комната. Желающие посовещаться заполняют
 * заявки с желаемым временем начала и конца. Ваша задача определить максимальное количество
 * заявок, которое может быть удовлетворено. Число заявок ≤ 100000.
 *
 * Алгоритм: сортируем отрезки времени из заявок по их правым концам и в каждый момент времени
 * выбираем первую подходящую встречу и ищем следующую за ней подходящую.
 *
 * Обоснование жадности:
 * Назовем оптимальной любую последовательность одобренных заявок, их число в которой максимально.
 * Пусть наш алгоритм получает ответ меньше, чем оптимальный. Тогда возьмем последовательность
 * заявок, которую нашел наш алгоритм. Она, очевидно, на какой-то позиции отличается от оптимальной.
 * Тогда в нашей последовательности там стоит отрезок [l, r], в оптимальной [L, R], a r0 - конец
 * предыдущего (совпадающего!) отрезка. Тогда заметим, что l >= r0 и L >= r0, но r <= R, т.к. он стоит
 * раньше в нашем отсортированном массиве (иначе бы мы бы выбрали отрезок [L, R]). Таким образом,
 * мы можем заменить один отрезок в оптимальной последовательности на наш, тем самым никак не нарушив
 * её корректность и оптимальность, при этом продлив общую часть с нашей последовательностью.
 * Значит, найденная нами последовательность тоже оптимальна (т.к. конечна). А значит, ответ верен.
 */

using namespace std;

bool cmp(pair<int, int> a, pair<int, int> b) {
    if (a.second < b.second)
        return true;
    return false;
}

int main() {
    // Вводим данные
    vector<pair<int, int> > meetings;
    int b, e, n = 0;
    while (cin >> b >> e) {
        meetings.push_back({b, e});
        n++;
    }

    // Сортируем встречи
    sort(meetings.begin(), meetings.end(), cmp);

    // Ищем ответ по описанному алгоритму
    int j = 0, ans = 1;
    for (int i = 1; i < n; i++) {
        if (meetings[i].first >= meetings[j].second) {
            ans++;
            j = i;
        }
    }

    cout << ans;

    return 0;
}
