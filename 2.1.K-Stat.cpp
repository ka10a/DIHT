#include <vector>
#include <iostream>
#include <cstdlib>

/* Даны неотрицательные целые числа n, k и массив целых чисел из диапазона [0..109] размера n.
 * Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое бы стояло на позиции
 * с индексом k ∈ [0..n-1] в отсортированном массиве. Напишите нерекурсивный алгоритм.
 * Требования к дополнительной памяти: O(n). Требуемое среднее время работы: O(n).
 * Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении.
 * Описание для случая прохода от начала массива к концу: Выбирается опорный элемент.
 * Опорный элемент меняется с последним элементом массива.
 * Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного.
 * Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат нерассмотренные элементы.
 * Последним элементом лежит опорный.
 * Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
 * Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
 * Шаг алгоритма. Рассматривается элемент, на который указывает j. Если он больше опорного, то сдвигаем j.
 * Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
 * В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.
*/

using namespace std;

int Partition(vector<int>& arr, int beginning, int ending) {
    // Если в куске [beginning, ending] 0 или 1 элемент, их можно не сортировать
    if(ending - beginning <= 0)
        return beginning;

    // Выбор опорного элемента рандомом
    int pivot = (rand() % (ending - beginning)) + beginning;

    // Чтобы опорный элемент ни с кем не поменять, меняем его с последним и сортируем только [beginning, ending]
    swap(arr[pivot], arr[ending]);
    int i = beginning, j = ending - 1;

    while( i <= j ) {
        // Ищем первый элемент больший опорного
        for( ; (arr[i] < arr[ending]); ++i ) {}

        // Ищем первый элемент меньший опорного
        for( ; (j >= beginning) && (arr[j] >= arr[ending]); --j ) {}

        // Меняем их местами
        if(i < j)
            swap(arr[i++], arr[j--]);
    }

    // Ставим опорный элемент на свое место
    swap(arr[i], arr[ending]);

    return i;
}

// Ищет К-ю порядковую статистику
int find_k_stat(int k, int n, vector<int>& arr) {
    int beginning = 0, ending = n - 1;
    int ind = Partition(arr, beginning, ending);
    while (ind != k) {
        // Если поставленный на место элемент лежит дальше нужного
        if (ind > k) {
            ending = ind - 1;
        }
        else {
            beginning = ind + 1;
        }
        
        ind = Partition(arr, beginning, ending);
    }

    return ind;
}

int main() {
    int n, k;
    cin >> n >> k;

    vector<int> arr(n);

    for (int i = 0; i < n; ++i) {
        cin  >> arr[i];
    }

    cout << arr[find_k_stat(k, n, arr)];

    return 0;
}
