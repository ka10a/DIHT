#include <vector>
#include <iostream>
#include <cstdlib>

/*Даны неотрицательные целые числа n, k и массив целых чисел из диапазона [0..109] размера n.
Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое бы стояло на позиции
с индексом k ∈[0..n-1] в отсортированном массиве. Напишите нерекурсивный алгоритм.
Требования к дополнительной памяти: O(n). Требуемое среднее время работы: O(n).
Функцию Partition   следует реализовывать методом прохода двумя итераторами в одном направлении.
Описание для случая прохода от начала массива к концу: Выбирается опорный элемент.
Опорный элемент меняется с последним элементом массива.
Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного.
Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат нерассмотренные элементы.
Последним элементом лежит опорный.
Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
Шаг алгоритма. Рассматривается элемент, на который указывает j. Если он больше опорного, то сдвигаем j.
Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.
*/

using namespace std;

int Partition(vector<int> &arr, int beginning, int ending) {

    // Если в куске [beginning, ending] 0 или 1 элемент, их можно не сортировать
    if(ending - beginning <= 0)
        return beginning;

    // Выбор опорного элемента рандомом
    int pivot = (rand() % (ending - beginning)) + beginning;

    // Чтобы опорный элемент ни с кем не поменять, меняем его с последним и сортируем только [beginning, ending)
    swap(arr[pivot], arr[ending]);
    int i = beginning, j = ending - 1;

    while( i <= j ) {

        // Ищем первый элемент больший опорного
        for( ; (arr[i] < arr[ending]); ++i ) {}

        // Ищем первый элемент меньший опорного
        for( ; (j >= beginning) && (arr[j] >= arr[ending]); --j ) {}

        // Меняем их местами
        if(i < j)
            swap(arr[i++], arr[j--]);
    }

    // Ставим опорный элемент на свое место
    swap(arr[i], arr[ending]);

    return i;
}


// Ищет К-ю порядковую статистику
int find_k_stat(int k, int n, vector<int> &arr){
    int beginning = 0, ending = n - 1;
    int ind = Partition(arr, beginning, ending);
    while (ind != k){

        // Если поставленный на место элемент лежит дальше нужного
        if (ind > k)
            ending = ind - 1;
        else
            beginning = ind + 1;

        ind = Partition(arr, beginning, ending);
    }

    return ind;
}

int main(){
    int n, k;
    cin >> n >> k;

    vector<int> arr(n);

    for (int i = 0; i < n; i++){
        cin  >> arr[i];
    }

    cout << arr[find_k_stat(k, n, arr)];

    return 0;
}
